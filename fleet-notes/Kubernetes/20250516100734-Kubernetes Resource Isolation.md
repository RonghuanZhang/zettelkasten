---
"type:": fleet-note
"title:": 20250516100734-Kubernetes Resource Isolation
"id:": 20250516100750
"created:": 2025-05-16T10:07:50
url: 
tags:
  - fleet-note
  - kubernetes
"processed:": false
"archived:": false
---

用户模拟我觉的是可以用的

Set the ClusterRole to operate the resource, like the pod, service, etc.

Bind the ClusterRole to the service account generated by the platform for every user.


在生产环境中实现“用户隔离”（Tenant Isolation），关键在于**身份认证（Authentication）**与**授权（Authorization）**的设计。下面先给出整体思路梳理，随后分步详细说明。

> **总结**
> 
> 1. **按用户（租户）创建 Namespace + ServiceAccount**：每个用户 A 对应一个 Namespace A 和一个 ServiceAccount A，用于隔离资源和身份；
>     
> 2. **绑定最小权限的 Role/RoleBinding**：只允许 ServiceAccount A 在 Namespace A 内操作；
>     
> 3. **Java 客户端中使用 ServiceAccount Token 或者 Impersonation**：
>     
>     - **直接用 Token**：在应用启动时读取对应 SA 的 Token（静态或动态 TokenRequest），并注入到 `ApiClient`；
>         
>     - **用 Impersonation**：让一个具有跨命名空间获取 Token 权限的主账号，在每次请求时“模拟”成对应的 ServiceAccount；
>         
> 4. **推荐使用 TokenRequest API 获取短期 Token**，避免长期 Token 泄露风险；
>     
> 5. **严格遵循最小权限原则**，定期审计与旋转 Token。
>     

---

## 1. 用户隔离与 Namespace

### Namespace 隔离

Kubernetes 通过 Namespace 将 API 资源逻辑隔离，每个 Namespace 内的资源名称可以重复，且大多数安全策略（RBAC、NetworkPolicy）都支持按 Namespace 作用域限制权限 ([Kubernetes](https://kubernetes.io/docs/concepts/security/multi-tenancy/?utm_source=chatgpt.com "Multi-tenancy | Kubernetes"))。  
多租户场景下，通常为每个租户（用户）都创建单独的 Namespace，以确保租户间的控制平面（API Server）和数据平面（网络、存储）隔离 ([Stack Overflow](https://stackoverflow.com/questions/65291998/kubernetes-create-a-separate-namespace-for-each-customer?utm_source=chatgpt.com "Kubernetes - Create a separate namespace for each customer"))。

---

## 2. 身份认证方式（Authentication）

### 2.1 ServiceAccount Token

- Kubernetes 内置的非人类身份由 ServiceAccount 提供，每个 Namespace 默认带有一个 `default` ServiceAccount，也可自定义创建 ([Kubernetes](https://kubernetes.io/docs/concepts/security/service-accounts/?utm_source=chatgpt.com "Service Accounts | Kubernetes"))。
    
- ServiceAccount 的身份由其挂载的 Bearer Token（Secret 对象）提供，API Server 会将其映射为用户名 `system:serviceaccount:{namespace}:{sa}` 并加入对应组 `system:serviceaccounts`、`system:serviceaccounts:{namespace}` ([Kubernetes](https://kubernetes.io/docs/reference/access-authn-authz/authentication/?utm_source=chatgpt.com "Authenticating | Kubernetes"))。
    

### 2.2 外部身份（OIDC）与 TokenReview

- 对于人类用户，可通过 OIDC 等外部身份提供者让 API Server 验证 JWT，并将用户映射到 Kubernetes 用户或组。
    
- 在 Java 应用中，你可以先将用户的外部 Token 提交到 Kubernetes 的 TokenReview API 验证，然后再调用后续接口 ([Kubernetes](https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/?utm_source=chatgpt.com "Access Clusters Using the Kubernetes API"))。
    

---

## 3. Java SDK 中的认证处理

### 3.1 使用静态 ServiceAccount Token

- 在 Pod 中运行时，Kubelet 会自动将 ServiceAccount Token 挂载到 `/var/run/secrets/kubernetes.io/serviceaccount/token`，Java 客户端可直接读取并使用：
    
    ```java
    ApiClient client = Config.fromToken(
        "https://<apiserver>", 
        new String(Files.readAllBytes(Paths.get("/var/run/secrets/kubernetes.io/serviceaccount/token"))), 
        false);
    Configuration.setDefaultApiClient(client);
    ```
    
- 这种方式简单，但 Token 生命周期较长，不利于安全审计与旋转。
    

### 3.2 动态获取短期 Token（TokenRequest API）

- Kubernetes 1.20+ 提供 TokenRequest API，让你为指定 ServiceAccount 动态签发短期 Token。Java 客户端封装在 `CoreV1Api.createNamespacedServiceAccountToken` 方法中 ([Javadoc](https://javadoc.io/doc/io.kubernetes/client-java-api/12.0.1/io/kubernetes/client/openapi/apis/CoreV1Api.html?utm_source=chatgpt.com "CoreV1Api (client-java-api 12.0.1 API) - javadoc.io"))。
    
- 示例：
    
    ```java
    CoreV1Api api = new CoreV1Api(client);
    AuthenticationV1TokenRequest req = new AuthenticationV1TokenRequest()
        .audiences(Collections.singletonList("api"))
        .expirationSeconds(3600L);
    V1TokenRequest resp = api.createNamespacedServiceAccountToken(
        "sa-name", "namespace", req, null, null, null);
    String token = resp.getStatus().getToken();
    // 将 token 注入新的 ApiClient
    ApiClient saClient = Config.fromToken("https://<apiserver>", token, false);
    Configuration.setDefaultApiClient(saClient);
    ```
    
- **优势**：Token 有效期短，漏出风险小，容易旋转 ([Sourcegraph](https://sourcegraph.com/github.com/kubernetes-client/java/-/blob/kubernetes/docs/CoreV1Api.md?utm_source=chatgpt.com "CoreV1Api.md - kubernetes-client/java - Sourcegraph"))。
    

### 3.3 用户模拟（Impersonation）

- 在某些场景，你可能希望由一个主管理账号生成对各 ServiceAccount 的访问，而不直接存储多个 Token。Kubernetes 支持用户模拟（Impersonation）机制，通过 HTTP Header `Impersonate-User`、`Impersonate-Group` 实现 ([Kubernetes](https://kubernetes.io/docs/reference/access-authn-authz/authentication/?utm_source=chatgpt.com "Authenticating | Kubernetes"))。
    
- Fabric8 和官方 Java 客户端均支持在 `ApiClient` 中配置模拟用户：
    
    ```java
    client.getRequestConfig().setImpersonateUsername("system:serviceaccount:ns:sa-name");
    client.getRequestConfig().setImpersonateGroup("system:serviceaccounts:ns");
    ```
    
- API Server 会先验证调用者身份及其 `impersonate` 权限（需为你主账号授予 `impersonate` 换发 SA Token 的权限），然后再以被模拟身份执行业务请求 ([GitHub](https://github.com/kubernetes-client/java/issues/1563?utm_source=chatgpt.com "Is Impersonator supported in Kubernetes client library? #1563 - GitHub"))。
    

---

## 4. 授权控制（Authorization）

- 利用 RBAC，为每个 ServiceAccount 在其对应 Namespace 内创建精细化的 Role + RoleBinding，只允许所需操作（如 CRUD Pod/ConfigMap 等） ([Kubernetes](https://kubernetes.io/docs/concepts/security/multi-tenancy/?utm_source=chatgpt.com "Multi-tenancy | Kubernetes"))。
    
- 严格遵循最小权限原则，不要给 ServiceAccount 超出业务需求的权限。
    

---

## 5. 实践步骤

1. **创建 Namespace 与 ServiceAccount**
    
    ```bash
    kubectl create namespace user-a
    kubectl create serviceaccount sa-user-a -n user-a
    ```
    
2. **绑定最小权限 Role**
    
    ```yaml
    kind: Role
    apiVersion: rbac.authorization.k8s.io/v1
    metadata: { name: role-reader, namespace: user-a }
    rules: [{ apiGroups: [""], resources: ["pods","configmaps"], verbs: ["get","list"] }]
    ---
    kind: RoleBinding
    apiVersion: rbac.authorization.k8s.io/v1
    metadata: { name: bind-reader, namespace: user-a }
    subjects: [{ kind: ServiceAccount, name: sa-user-a, namespace: user-a }]
    roleRef: { kind: Role, name: role-reader, apiGroup: rbac.authorization.k8s.io }
    ```
    
3. **Java 中获取并使用 Token**
    
    - **选项 A**：直接读取挂载的 Token；
        
    - **选项 B**：使用 TokenRequest API；
        
    - **选项 C**：使用 Impersonation，由主账号动态“模拟”成对应 SA。
        
4. **定期审计与 Token 旋转**：结合 Kubernetes 的 TokenReview、Audit Log 保证安全合规。
    

---

## 6. 最佳实践

- **短期 Token**：优先使用 TokenRequest API，避免长期 Token 泄露。
    
- **Least Privilege**：Role/RoleBinding 精确到操作粒度。
    
- **审计与监控**：开启 API Server 审计日志，并定期检查 ServiceAccount Secret 访问权限。
    
- **自动化**：用 CI/CD 或 Operator 管理多租户资源的创建、绑定及清理。
    

通过以上方案，Java 应用在生产环境中即可实现“用户 A 只能用 ServiceAccount A 访问 Namespace A”的严格隔离，兼顾安全与可维护性。

# Reference
* [Best practices for GKE RBAC  \|  Google Kubernetes Engine (GKE)  \|  Google Cloud](https://cloud.google.com/kubernetes-engine/docs/best-practices/rbac)
* [Authenticating \| Kubernetes](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)
* [[20250516100014-Kubernetes Service Account]]
* [[20250516140450-K8s service account 资源隔离]]